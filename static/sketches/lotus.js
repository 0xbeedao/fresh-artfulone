/* Do not edit - autogenerated */
  // contents/sketches/lib/colors.ts
  var RingStack = class _RingStack {
    constructor(series, options = {}) {
      this.series = series;
      this.options = options;
      this.index = -1;
    }
    burn(index = -1) {
      let burnIx = index === -1 ? this.index : index % this.series.length;
      if (burnIx === -1) {
        burnIx = 0;
      }
      const val = this.series[burnIx];
      const trimmed = [];
      this.series.forEach((c, ix) => {
        if (ix !== burnIx) {
          trimmed.push(c);
        }
      });
      this.series = trimmed;
      this.reset(index);
      return val;
    }
    burnRandom() {
      const index = Math.floor(Math.random() * this.series.length);
      return this.burn(index);
    }
    duplicate() {
      return new _RingStack(this.series);
    }
    dict(names) {
      const ret = {};
      names.forEach((c, ix) => {
        const key = names[ix];
        ret[names[ix]] = key === "bg" ? this.background() : this.next();
      });
      return ret;
    }
    get(index) {
      if (index === void 0) {
        return this.get(this.index);
      }
      return this.series[index % this.series.length];
    }
    next(count = 1) {
      this.reset(this.index + 1);
      if (count === 1) {
        return this.get(this.index);
      }
      const ret = [];
      for (let i = 0; i < count; i++) {
        ret.push(this.get(this.index + i));
      }
      return ret;
    }
    random() {
      const index = int(random(this.series.length));
      return this.series[index];
    }
    reset(ix = 0) {
      this.index = ix % this.series.length;
      return this;
    }
    shuffle() {
      this.series = shuffle(this.series);
      return this;
    }
  };
  var ColorStack = class _ColorStack extends RingStack {
    duplicate() {
      return new _ColorStack(this.series);
    }
    background() {
      if (!this.options.background) {
        this.options.background = this.burnRandom();
      }
      return this.options.background;
    }
    stroke() {
      if (!this.options.stroke) {
        this.options.stroke = this.burnRandom();
      }
      return this.options.stroke;
    }
    nextWithOpacity(opacity) {
      const val = this.next();
      const r = val.slice(1, 3);
      const g = val.slice(3, 5);
      const b = val.slice(5, 7);
      const rgba = `rgba(${unhex(r)}, ${unhex(g)}, ${unhex(b)}, ${opacity})`;
      return color(rgba);
    }
  };
  function chromatomeColors(pallette) {
    if (!pallette) {
      return new ColorStack(chromotome.getRandom().colors);
    }
    const chroma = chromotome.get(pallette);
    return new ColorStack(chroma.colors, chroma);
  }

  // contents/sketches/lotus.ts
  var colors;
  var span;
  function SawTooth(x, y, span2, teeth, fg, triangleWidth) {
    const increment = 2 * PI / teeth;
    noStroke();
    fill(fg);
    for (let i = 0; i < teeth; i++) {
      i > 0 && rotate(increment);
      triangle(0, -span2 / triangleWidth, 0, span2 / triangleWidth, span2 / 2, 0);
    }
  }
  var usableHeight = 500;
  var usableWidth = 500;
  function setup() {
    const canvasElement = document.getElementById("lotus");
    if (canvasElement) {
      usableHeight = parseInt(canvasElement.height, 10);
      usableWidth = parseInt(canvasElement.width, 10);
    }
    console.table({ usableHeight, usableWidth });
    console.log("canvasElement", canvasElement);
    createCanvas(usableWidth, usableHeight, canvasElement);
    colors = chromatomeColors();
    background(colors.background());
    const smaller = min(usableHeight, usableWidth);
    span = smaller / 4.25;
    const frameSpeed = Math.floor(Math.random() * 10) + 7;
    frameRate(frameSpeed);
  }
  var running = true;
  function keyPressed(code) {
    console.log("code", code);
    if (!running) {
      running = true;
      loop();
    } else {
      running = false;
      noLoop();
    }
  }
  function Lotus(x, y, span2, petals, petalColor, innerColor, dotColor) {
    push();
    translate(x, y);
    SawTooth(0, 0, span2, petals, petalColor, 2);
    const seg = PI / petals;
    for (let i = 0; i < petals * 2; i++) {
      rotate(seg);
      fill(innerColor);
      circle(span2 / 4, 0, span2 / 12);
      triangle(span2 / 6, span2 / 16, span2 / 6, -span2 / 16, span2 / 3, 0);
      fill(dotColor);
      circle(span2 / 5, 0, span2 / 32);
    }
    noFill();
    strokeWeight(span2 / 48);
    stroke(petalColor);
    circle(0, 0, span2 / 3.1);
    pop();
  }
  function drawAll(color2, span2, r) {
    let s1 = colors.next();
    let fg1 = colors.next();
    let fg2 = colors.next();
    Lotus(0, 0, span2 * 1.5, 6, s1, fg1, fg2);
    rotate(-r);
    s1 = colors.next();
    fg1 = colors.next();
    fg2 = colors.next();
    const s1b = colors.next();
    const fg1b = colors.next();
    const fg2b = colors.next();
    const seg = PI / 6;
    for (let i = 0; i < 12; i++) {
      i > 0 && rotate(seg);
      if (i % 2 === 0) {
        Lotus(span2 * 2, 0, span2 * 0.66, 8, s1b, fg1b, fg2b);
        stroke(s1);
        strokeWeight(span2 / 32);
        line(span2 * 0.8, 0, span2 * 1.6, 0);
        noStroke();
      } else {
        Lotus(span2 * 1.5, 0, span2, 8, s1, fg1, fg2);
      }
    }
  }
  function draw() {
    clear();
    colors.reset();
    translate(usableWidth / 2, usableHeight / 2);
    drawAll(color, span, frameCount % (40 * PI));
  }
  function mousePressed() {
    if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
      let fs = fullscreen();
      fullscreen(!fs);
    }
  }