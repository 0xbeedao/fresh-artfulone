/* Do not edit - autogenerated */
  // contents/sketches/lib/colors.ts
  var RingStack = class _RingStack {
    constructor(series, options = {}) {
      this.series = series;
      this.options = options;
      this.index = -1;
    }
    burn(index = -1) {
      let burnIx = index === -1 ? this.index : index % this.series.length;
      if (burnIx === -1) {
        burnIx = 0;
      }
      const val = this.series[burnIx];
      const trimmed = [];
      this.series.forEach((c, ix) => {
        if (ix !== burnIx) {
          trimmed.push(c);
        }
      });
      this.series = trimmed;
      this.reset(index);
      return val;
    }
    burnRandom() {
      const index = Math.floor(Math.random() * this.series.length);
      return this.burn(index);
    }
    duplicate() {
      return new _RingStack(this.series);
    }
    dict(names) {
      const ret = {};
      names.forEach((c, ix) => {
        const key = names[ix];
        ret[names[ix]] = key === "bg" ? this.background() : this.next();
      });
      return ret;
    }
    get(index) {
      if (index === void 0) {
        return this.get(this.index);
      }
      return this.series[index % this.series.length];
    }
    next(count = 1) {
      this.reset(this.index + 1);
      if (count === 1) {
        return this.get(this.index);
      }
      const ret = [];
      for (let i = 0; i < count; i++) {
        ret.push(this.get(this.index + i));
      }
      return ret;
    }
    random() {
      const index = int(random(this.series.length));
      return this.series[index];
    }
    reset(ix = 0) {
      this.index = ix % this.series.length;
      return this;
    }
    shuffle() {
      this.series = shuffle(this.series);
      return this;
    }
  };
  var ColorStack = class _ColorStack extends RingStack {
    duplicate() {
      return new _ColorStack(this.series);
    }
    background() {
      if (!this.options.background) {
        this.options.background = this.burnRandom();
      }
      return this.options.background;
    }
    stroke() {
      if (!this.options.stroke) {
        this.options.stroke = this.burnRandom();
      }
      return this.options.stroke;
    }
    nextWithOpacity(opacity) {
      const val = this.next();
      const r = val.slice(1, 3);
      const g = val.slice(3, 5);
      const b = val.slice(5, 7);
      const rgba = `rgba(${unhex(r)}, ${unhex(g)}, ${unhex(b)}, ${opacity})`;
      return color(rgba);
    }
  };
  function chromatomeColors(pallette) {
    if (!pallette) {
      return new ColorStack(chromotome.getRandom().colors);
    }
    const chroma = chromotome.get(pallette);
    return new ColorStack(chroma.colors, chroma);
  }

  // contents/sketches/lib/patterns.ts
  var PatternController = class {
    x;
    y;
    w;
    h;
    colors;
    angle;
    patternFunction;
    renderTarget;
    constructor() {
      this.x = 0;
      this.y = 0;
      this.w = 0;
      this.h = 0;
      this.colors = ["#FFFFFF", "#000000"];
      this.angle = 0;
      this.patternFunction = null;
      this.renderTarget = null;
    }
    patternAngle(_angle) {
      if (typeof _angle === "number") this.angle = _angle;
      return this.angle;
    }
    setPatternFunction(_func) {
      if (typeof _func !== "function") return false;
      this.patternFunction = _func;
      return this.patternFunction;
    }
    applyPattern(_x, _y, _w, _h, _renderTarget) {
      this._setPatternArea(_x, _y, _w, _h);
      this._setRenderTarget(_renderTarget);
      this.renderTarget = _renderTarget;
      this._drawPattern();
    }
    patternColors(_colsArr) {
      if (Array.isArray(_colsArr)) this.colors = _colsArr;
      return this.colors.slice(0, this.colors.length);
    }
    _setPatternArea(_x, _y, _w, _h) {
      this.x = _x;
      this.y = _y;
      this.w = _w;
      this.h = _h;
    }
    _setRenderTarget(_renderTarget) {
      this.renderTarget = _renderTarget;
    }
    _drawPattern() {
      const rt = this.renderTarget;
      const func = typeof this.patternFunction === "function" ? this.patternFunction : this._flatFill();
      const rotatedFunc = this._rotatedFuncGen(func, this.angle);
      const pRectMode = rt._renderer._rectMode;
      const pEllipseMode = rt._renderer._ellipseMode;
      rt.push();
      rt.drawingContext.clip();
      rt.translate(this.x, this.y);
      rotatedFunc(this.w, this.h, rt);
      rt.pop();
      rt.rectMode(pRectMode);
      rt.ellipseMode(pEllipseMode);
    }
    _rotatedFuncGen(_ptnFunc, _angle) {
      const func = function(_w, _h, _rt) {
        const p1 = _rt.createVector(-_w / 2, _h / 2).rotate(_angle);
        const p2 = _rt.createVector(_w / 2, _h / 2).rotate(_angle);
        const nw = Math.max(Math.abs(p1.x), Math.abs(p2.x)) * 2;
        const nh = Math.max(Math.abs(p1.y), Math.abs(p2.y)) * 2;
        _rt.push();
        _rt.translate(_w / 2, _h / 2);
        _rt.rotate(_angle);
        _rt.translate(-nw / 2, -nh / 2);
        _ptnFunc(nw, nh, _rt);
        _rt.pop();
      };
      return func;
    }
    _flatFill() {
      const c = this.patternColors(this.colors);
      return function(_w, _h, _rt) {
        _rt.rectMode(_rt.CORNER);
        _rt.fill(c[0]);
        _rt.noStroke();
        _rt.rect(0, 0, _w, _h);
      };
    }
  };
  var PatternVertexInfo = class {
    verticies;
    isCurve;
    curveAreaMult;
    constructor() {
      this.verticies = [];
      this.isCurve = false;
      this.curveAreaMult = 1.25;
    }
    reset() {
      this.verticies = [];
      this.isCurve = false;
    }
    addVertex(x, y) {
      this.verticies.push([x, y]);
    }
    addCurveVertex(x, y) {
      this.addVertex(x, y);
      this.isCurve = true;
    }
    addBezierVertex(x2, y2, x3, y3, x4, y4) {
      this.addVertex(x2, y2);
      this.addVertex(x3, y3);
      this.addVertex(x4, y4);
    }
    addQuadraticVertex(cx, cy, x3, y3) {
      this.addVertex(cx, cy);
      this.addVertex(x3, y3);
    }
    culclateArea() {
      let minx = this.verticies[0][0];
      let maxx = minx;
      let miny = this.verticies[0][1];
      let maxy = miny;
      for (let i = 0; i < this.verticies.length; i++) {
        let nx = this.verticies[i][0];
        let ny = this.verticies[i][1];
        minx = Math.min(minx, nx);
        maxx = Math.max(maxx, nx);
        miny = Math.min(miny, ny);
        maxy = Math.max(maxy, ny);
      }
      let w = maxx - minx;
      let h = maxy - miny;
      let cx = w / 2 + minx;
      let cy = h / 2 + miny;
      if (this.isCurve) {
        w *= this.curveAreaMult;
        h *= this.curveAreaMult;
      }
      let x = cx - w / 2;
      let y = cy - h / 2;
      const area = { x, y, w, h };
      return area;
    }
  };
  p5.prototype._patternController = new PatternController();
  p5.Graphics.prototype._patternController = new PatternController();
  p5.prototype._patternVertexInfo = new PatternVertexInfo();
  p5.Graphics.prototype._patternVertexInfo = new PatternVertexInfo();
  p5.prototype.patternAngle = function(_angle) {
    return this._patternController.patternAngle(_angle);
  };
  p5.prototype.patternColors = function(_colsArr) {
    return this._patternController.patternColors(_colsArr);
  };
  p5.prototype.pattern = function(_func) {
    return this._patternController.setPatternFunction(_func);
  };
  (function() {
    const _modeAdjust = function(a, b, c, d, mode) {
      if (mode === p5.prototype.CORNER) {
        return { x: a, y: b, w: c, h: d };
      } else if (mode === p5.prototype.CORNERS) {
        return { x: a, y: b, w: c - a, h: d - b };
      } else if (mode === p5.prototype.RAIUS) {
        return { x: a - c, y: b - d, w: 2 * c, h: 2 * d };
      } else if (mode === p5.prototype.CENTER) {
        return { x: a - c * 0.5, y: b - d * 0.5, w: c, h: d };
      }
    };
    const _disableColor = function(_renderTarget) {
      _renderTarget.noStroke();
      _renderTarget.fill(255, 0);
    };
    p5.prototype.rectPattern = function(...args) {
      _disableColor(this);
      const r = this.rect(...args);
      const val = _modeAdjust(
        arguments[0],
        arguments[1],
        arguments[2],
        arguments[3],
        this._renderer._rectMode
      );
      this._patternController.applyPattern(val.x, val.y, val.w, val.h, this);
      return r;
    };
    p5.prototype.squarePattern = function(...args) {
      _disableColor(this);
      const r = this.square(...args);
      const val = _modeAdjust(
        arguments[0],
        arguments[1],
        arguments[2],
        arguments[2],
        this._renderer._rectMode
      );
      this._patternController.applyPattern(val.x, val.y, val.w, val.h, this);
      return r;
    };
    p5.prototype.ellipsePattern = function(...args) {
      _disableColor(this);
      const r = this.ellipse(...args);
      const val = _modeAdjust(
        arguments[0],
        arguments[1],
        arguments[2],
        arguments[3],
        this._renderer._ellipseMode
      );
      this._patternController.applyPattern(val.x, val.y, val.w, val.h, this);
      return r;
    };
    p5.prototype.arcPattern = function(...args) {
      _disableColor(this);
      const r = this.arc(...args);
      const val = _modeAdjust(
        arguments[0],
        arguments[1],
        arguments[2],
        arguments[3],
        this._renderer._ellipseMode
      );
      this._patternController.applyPattern(val.x, val.y, val.w, val.h, this);
      return r;
    };
    p5.prototype.circlePattern = function(...args) {
      _disableColor(this);
      const r = this.circle(...args);
      const val = _modeAdjust(
        arguments[0],
        arguments[1],
        arguments[2],
        arguments[2],
        this._renderer._ellipseMode
      );
      this._patternController.applyPattern(val.x, val.y, val.w, val.h, this);
      return r;
    };
    p5.prototype.trianglePattern = function(...args) {
      _disableColor(this);
      const r = this.triangle(...args);
      const cx = (arguments[0] + arguments[2] + arguments[4]) / 3;
      const cy = (arguments[1] + arguments[3] + arguments[5]) / 3;
      const w = this.max([
        Math.abs(cx - arguments[0]),
        Math.abs(cx - arguments[2]),
        Math.abs(cx - arguments[4])
      ]) * 2;
      const h = this.max([
        Math.abs(cy - arguments[1]),
        Math.abs(cy - arguments[3]),
        Math.abs(cy - arguments[5])
      ]) * 2;
      this._patternController.applyPattern(cx - w / 2, cy - h / 2, w, h, this);
      return r;
    };
    p5.prototype.quadPattern = function(...args) {
      _disableColor(this);
      const r = this.quad(...args);
      const minX = this.min([
        arguments[0],
        arguments[2],
        arguments[4],
        arguments[6]
      ]);
      const maxX = this.max([
        arguments[0],
        arguments[2],
        arguments[4],
        arguments[6]
      ]);
      const minY = this.min([
        arguments[1],
        arguments[3],
        arguments[5],
        arguments[7]
      ]);
      const maxY = this.max([
        arguments[1],
        arguments[3],
        arguments[5],
        arguments[7]
      ]);
      this._patternController.applyPattern(
        minX,
        minY,
        maxX - minX,
        maxY - minY,
        this
      );
      return r;
    };
    p5.prototype.beginShapePattern = function(...args) {
      const r = this.beginShape(...args);
      this._patternVertexInfo.reset();
      return r;
    };
    p5.prototype.beginContourPattern = function(...args) {
      return this.beginContour(...args);
    };
    p5.prototype.vertexPattern = function(...args) {
      const r = this.vertex(...args);
      this._patternVertexInfo.addVertex(arguments[0], arguments[1]);
      return r;
    };
    p5.prototype.curveVertexPattern = function(...args) {
      const r = this.curveVertex(...args);
      this._patternVertexInfo.addCurveVertex(arguments[0], arguments[1]);
      return r;
    };
    p5.prototype.bezierVertexPattern = function(...args) {
      const r = this.bezierVertex(...args);
      this._patternVertexInfo.addBezierVertex(
        arguments[0],
        arguments[1],
        arguments[2],
        arguments[3],
        arguments[4],
        arguments[5]
      );
      return r;
    };
    p5.prototype.quadraticVertexPattern = function(...args) {
      const r = this.quadraticVertex(...args);
      this._patternVertexInfo.addQuadraticVertex(
        arguments[0],
        arguments[1],
        arguments[2],
        arguments[3]
      );
      return r;
    };
    p5.prototype.endContourPattern = function(...args) {
      return this.endContour(...args);
    };
    p5.prototype.endShapePattern = function(...args) {
      _disableColor(this);
      const r = this.endShape(...args);
      const area = this._patternVertexInfo.culclateArea();
      this._patternController.applyPattern(area.x, area.y, area.w, area.h, this);
      return r;
    };
  })();
  var PatternFunctions = class {
    density;
    rt;
    constructor(density = 0.2, rt = window) {
      this.density = density;
      this.rt = rt;
    }
    /**
     * Noise pattern
     * patternColors()[0]   base color
     * patternColors()[1]   dot color
     * @param {Number} _density  Density of dots. default = 0.2
     * Constrained between 0 and 1.
     */
    noise(_density) {
      const outerP5 = this.rt;
      const outerDensity = _density || this.density;
      const func = function(_w, _h, _rt) {
        const rt = _rt || outerP5;
        const density = rt.constrain(outerDensity, 0, 1);
        const c = rt.patternColors();
        const num = _w * _h * density;
        const ns = 0.01;
        rt.ellipseMode(rt.CENTER);
        rt.rectMode(rt.CORNER);
        rt.noStroke();
        rt.fill(c[0]);
        rt.rect(0, 0, _w, _h);
        rt.fill(c[1 % c.length]);
        for (let i = 0; i < num; i++) {
          const x = rt.random(_w);
          const y = rt.random(_h);
          const dia = rt.noise(x * ns, y * ns) * 0.5 + 1;
          rt.ellipse(x, y, dia, dia);
        }
      };
      return func;
    }
    /**
     * Noise gradient pattern
     * patternColors()[0]   base color
     * patternColors()[1]   dot color
     * @param {Number} _density  Density of dots. default = 0.2
     */
    noiseGrad(_density) {
      const outerP5 = this.rt;
      const outerDensity = _density || this.density;
      const func = function(_w, _h, _rt = window) {
        const rt = _rt || outerP5;
        const density = _rt.min(1, outerDensity);
        const c = _rt.patternColors();
        const num = _w * _h * density;
        const ns = 0.01;
        _rt.rectMode(_rt.CORNER);
        _rt.ellipseMode(_rt.CENTER);
        _rt.noStroke();
        _rt.fill(c[0]);
        _rt.rect(0, 0, _w, _h);
        _rt.fill(c[1 % c.length]);
        for (let i = 0; i < num; i++) {
          const x = _rt.abs(_rt.randomGaussian()) / 5 * _w;
          const y = _rt.random(_h);
          const dia = _rt.noise(x * ns, y * ns) * 0.5 + 1;
          _rt.ellipse(x, y, dia, dia);
        }
      };
      return func;
    }
    /**
     * Stripe pattern
     * Fill the colors of patternColors() in order.
     * @param {Number} _space   Stripe space. default = 10
     */
    stripe(_space = 10) {
      const func = function(_w, _h, _rt = window) {
        _space = Math.abs(_space);
        if (_space == 0) _space = 10;
        const c = _rt.patternColors();
        _rt.rectMode(_rt.CORNER);
        _rt.noStroke();
        let count = 0;
        for (let x = 0; x <= _w + _space; x += _space) {
          _rt.fill(c[count % c.length]);
          _rt.rect(x, 0, Math.ceil(_space), _h);
          count++;
        }
      };
      return func;
    }
    /**
     * Concentric circle stripe pattern.
     * Fill the colors of patternColors() in order.
     * @param {Number} _space      Stripe space. default = 10
     * @param {Number} _minRadius  Minimum radius. default = 0
     */
    stripeCircle(_space = 25, _minRadius = 0) {
      const func = function(_w, _h, _rt = window) {
        _space = _rt.abs(_space);
        if (_space == 0) _space = 25;
        const c = _rt.patternColors();
        const maxRadius = _rt.sqrt(_w * _w + _h * _h);
        const num = _rt.ceil((maxRadius - _minRadius) / _space);
        _rt.ellipseMode(_rt.CENTER);
        _rt.noStroke();
        for (let i = 0; i < num; i++) {
          _rt.fill(c[i % c.length]);
          const radius = _minRadius + (num - 1 - i) * _space;
          _rt.circle(_w / 2, _h / 2, radius * 2);
        }
      };
      return func;
    }
    /**
     * Concentric polygon stripe pattern.
     * @param {Number} _vertNum     Number of vertices in a polygon,
     *                              constrained between 3 and 20.    default = 3
     * @param {Number} _space       Stripe space. default = 10
     * @param {Number} _minRadius   Minimum radius. default = 0
     */
    stripePolygon(_vertNum = 3, _space = 25, _minRadius = 0) {
      const func = function(_w, _h, _rt = window) {
        _space = _rt.abs(_space);
        if (_space == 0) _space = 25;
        const vNum = _rt.int(_rt.constrain(_vertNum, 3, 30));
        const c = _rt.patternColors();
        const maxRadius = _rt.sqrt(_w * _w + _h * _h);
        const num = _rt.ceil((maxRadius - _minRadius) / _space);
        _rt.noStroke();
        for (let i = 0; i < num; i++) {
          _rt.fill(c[i % c.length]);
          const radius = _minRadius + (num - 1 - i) * _space;
          _rt.beginShape();
          for (let i2 = 0; i2 < vNum; i2++) {
            const rad = i2 * Math.PI * 2 / vNum;
            const x = _w / 2 + Math.cos(rad) * radius;
            const y = _h / 2 + Math.sin(rad) * radius;
            _rt.vertex(x, y);
          }
          _rt.endShape(_rt.CLOSE);
        }
      };
      return func;
    }
    /**
     * Radial stripe pattern.
     * @param {Number} _angleSpan   Stripe angle space. default = PI / 4,
     * specified in radians or degrees, depending on current angleMode
     */
    stripeRadial(_angleSpan = 1) {
      const func = function(_w, _h, _rt = window) {
        _angleSpan = _rt.abs(_angleSpan);
        if (_angleSpan == 0) _angleSpan = 1;
        const c = _rt.patternColors();
        const tau = _rt._angleMode == _rt.DEGREES ? 360 : _rt.TAU;
        _rt.ellipseMode(_rt.CENTER);
        _rt.noStroke();
        let count = 0;
        const dia = _rt.sqrt(_w * _w + _h * _h);
        for (let r = 0; r < tau; r += _angleSpan) {
          const endRad = r + _angleSpan > tau ? 1e-5 : r + _angleSpan;
          _rt.fill(c[count % c.length]);
          _rt.arc(_w / 2, _h / 2, dia, dia, r, endRad + 1e-4);
          count++;
        }
      };
      return func;
    }
    /**
     * Wave pattern
     * patternColors()[0]       base color
     * patternColors()[1]       wave color
     * @param {Number} _waveW   Wave width. default = 100
     * @param {Number} _waveH   Wave height. default = 20
     * @param {Number} _space   Line spacing. default = 20
     * @param {Number} _weight  Line weight. default = 5
     */
    wave(_waveW = 100, _waveH = 10, _space = 20, _weight = 5) {
      const func = function(_w, _h, _rt = window) {
        _space = _rt.abs(_space);
        if (_space == 0) _space = 20;
        _waveW = _rt.abs(_waveW);
        if (_waveW == 0) _waveW = 100;
        const c = _rt.patternColors();
        const vertSpan = 3;
        _rt.rectMode(_rt.CORNER);
        _rt.noStroke();
        _rt.fill(c[0]);
        _rt.rect(0, 0, _w, _h);
        _rt.fill(c[1]);
        for (let y = -_waveH; y <= _h + _waveH; y += _space) {
          _rt.beginShape();
          for (let x = 0; x < _w; x += vertSpan) {
            const rad = x / _waveW * _rt.TAU;
            _rt.vertex(x, y + Math.sin(rad) * _waveH);
          }
          _rt.vertex(_w, y + Math.sin(_w / _waveW * Math.PI * 2) * _waveH);
          for (let x = _w; x > 0; x -= vertSpan) {
            const rad = x / _waveW * Math.PI * 2;
            _rt.vertex(x, y + _weight + Math.sin(rad) * _waveH);
          }
          _rt.vertex(0, y + _weight + Math.sin(0) * _waveH);
          _rt.endShape(_rt.CLOSE);
        }
      };
      return func;
    }
    /*
      Private function.
      Generate tiling pattern functions.
      */
    _customTiling(_spaceX, _spaceY, _tileFunc, _useOffset = false) {
      const func = function(_w, _h, _rt) {
        _spaceX = _rt.abs(_spaceX);
        if (_spaceX == 0) _spaceX = 50;
        _spaceY = _rt.abs(_spaceY);
        if (_spaceY == 0) _spaceY = 50;
        const c = _rt.patternColors();
        _rt.rectMode(_rt.CORNER);
        _rt.noStroke();
        _rt.fill(c[0]);
        _rt.rect(0, 0, _w, _h);
        let yi = 0;
        _rt.fill(c[1]);
        for (let y = 0; y <= _h + _spaceY / 2; y += _spaceY) {
          let xi = 0;
          let offset = yi % 2 == 1 && _useOffset ? -_spaceX / 2 : 0;
          for (let x = offset; x <= _w + _spaceX / 2; x += _spaceX) {
            _rt.push();
            _rt.translate(x, y);
            _tileFunc(_rt, xi, yi);
            _rt.pop();
            xi++;
          }
          yi++;
        }
      };
      return func;
    }
    /**
     * Dot pattern
     * patternColors()[0]       base color
     * patternColors()[1]       Checked color
     * @param {Number} _space   Dot spacing. default = 15
     * @param {Number} _dia     Dot diameter. default = 15
     */
    dot(_space = 15, _dia = 7) {
      const func = this._customTiling(
        _space,
        _space,
        function(_rt) {
          _rt.noStroke();
          _rt.ellipseMode(_rt.CENTER);
          _rt.circle(0, 0, _dia);
        },
        false
      );
      return func;
    }
    /**
     * Checked pattern
     * patternColors()[0]       base color
     * patternColors()[1]       Checked color
     * @param {Number} _checkW    Width of checkered pattern. default = 10
     * @param {Number} _checkH    Height of checkered pattern (Optional)
     */
    checked(w = 10, h = 10) {
      if (w && !h) h = w;
      const func = this._customTiling(
        w * 2,
        h,
        function(_rt) {
          _rt.noStroke();
          _rt.rectMode(_rt.CORNER);
          _rt.rect(0, 0, w, h);
        },
        true
      );
      return func;
    }
    /**
     * Cross pattern
     * patternColors()[1]       base color
     * patternColors()[0]       line color
     * @param {Number} _space   Line spacing. default = 20
     * @param {Number} _weight  Line weight. default = 5
     */
    cross(_space = 20, _weight = 5) {
      const func = function(_w, _h, _rt = window) {
        const c = _rt.patternColors();
        _rt.rectMode(_rt.CORNER);
        _rt.fill(c[0]);
        _rt.rect(0, 0, _w, _h);
        _rt.fill(c[1 % c.length]);
        for (let y = 0; y < _h; y += _space) {
          _rt.rect(0, y + _space / 2 - _weight / 2, _w, _weight);
        }
        for (let x = 0; x < _w; x += _space) {
          _rt.rect(x + _space / 2 - _weight / 2, 0, _weight, _h);
        }
      };
      return func;
    }
    /**
     * Triangle pattern
     * patternColors()[0]       base color
     * patternColors()[1]       line color
     * @param {Number} _triW  Triangle width. default = 20
     * @param {Number} _triH  Triangle height. default = 20
     */
    triangle(_triW = 20, _triH = 20) {
      const func = this._customTiling(
        _triW,
        _triH,
        function(_rt) {
          _rt.noStroke();
          _rt.triangle(0, 0, _triW, 0, _triW / 2, _triH);
        },
        true
      );
      return func;
    }
  };

  // contents/sketches/lines-with-patterns.ts
  var colors = chromatomeColors();
  var lines = [];
  var linesNum = 60;
  var DIST = 10;
  var MAX;
  var GEN = 30;
  var stColor;
  var usableHeight = 500;
  var usableWidth = 500;
  function setup() {
    const canvasElement = document.getElementById("lines-with-patterns");
    if (canvasElement) {
      usableHeight = parseInt(canvasElement.height, 10);
      usableWidth = parseInt(canvasElement.width, 10);
    }
    console.table({ usableHeight, usableWidth });
    console.log("canvasElement", canvasElement);
    createCanvas(usableWidth, usableHeight, canvasElement);
    angleMode(DEGREES);
    MAX = Math.min(usableHeight, usableWidth);
    stColor = colors.next();
    for (let i = 0; i < linesNum; i++) {
      lines.push(new MyLine());
    }
    frameRate(30);
    console.log("setup complete");
  }
  function draw() {
    const bgColor = colors.background();
    background(bgColor);
    noStroke();
    for (let i = 0; i < lines.length; i++) {
      push();
      translate(width / 2, height / 2);
      rotate(360 * i / lines.length);
      lines[i].display();
      pop();
    }
    fill(bgColor);
    stroke(stColor);
    strokeWeight(10);
    circle(width / 2, height / 2, MAX * 0.2);
  }
  var MyLine = class {
    objs;
    speed;
    h;
    constructor() {
      this.objs = [];
      this.speed = random(3, 6);
      this.h = random(2, 10);
    }
    display() {
      if (random(100) < GEN) {
        if (this.objs.length == 0 || this.objs.length > 0 && this.objs[this.objs.length - 1].hasDistance()) {
          this.objs.push(new Obj(this.speed, this.h));
        }
      }
      for (let i = 0; i < this.objs.length; i++) {
        this.objs[i].move();
        this.objs[i].display();
      }
      if (this.objs.length > 0) {
        for (let j = this.objs.length - 1; j >= 0; j--) {
          if (this.objs[j].isFinished()) {
            this.objs.splice(j, 1);
          }
        }
      }
    }
  };
  var Obj = class {
    x;
    y;
    speed;
    w;
    h;
    c;
    pc;
    patternFuncs;
    constructor(tmpSpeed, tmpH) {
      this.x = 0;
      this.y = 0;
      this.speed = tmpSpeed;
      this.w = random(10, 100);
      this.h = tmpH;
      this.c = colors.next();
      this.pc = colors.next(3);
      this.patternFuncs = new PatternFunctions(0.2);
    }
    move() {
      this.x -= this.speed;
    }
    isFinished() {
      return this.x < -MAX * 0.6 - this.w;
    }
    hasDistance() {
      return this.x < -(this.w + DIST);
    }
    display() {
      fill(this.c);
      pattern(this.patternFuncs.stripe(20));
      patternColors(this.pc);
      rectPattern(this.x, this.y, this.w, this.h, this.h / 2);
    }
  };