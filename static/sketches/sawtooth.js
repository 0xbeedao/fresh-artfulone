/* Do not edit - autogenerated */
  // contents/sketches/lib/colors.ts
  var RingStack = class _RingStack {
    constructor(series, options = {}) {
      this.series = series;
      this.options = options;
      this.index = -1;
    }
    burn(index = -1) {
      let burnIx = index === -1 ? this.index : index % this.series.length;
      if (burnIx === -1) {
        burnIx = 0;
      }
      const val = this.series[burnIx];
      const trimmed = [];
      this.series.forEach((c, ix) => {
        if (ix !== burnIx) {
          trimmed.push(c);
        }
      });
      this.series = trimmed;
      this.reset(index);
      return val;
    }
    burnRandom() {
      const index = Math.floor(Math.random() * this.series.length);
      return this.burn(index);
    }
    duplicate() {
      return new _RingStack(this.series);
    }
    dict(names) {
      const ret = {};
      names.forEach((c, ix) => {
        const key2 = names[ix];
        ret[names[ix]] = key2 === "bg" ? this.background() : this.next();
      });
      return ret;
    }
    get(index) {
      if (index === void 0) {
        return this.get(this.index);
      }
      return this.series[index % this.series.length];
    }
    next(count = 1) {
      this.reset(this.index + 1);
      if (count === 1) {
        return this.get(this.index);
      }
      const ret = [];
      for (let i = 0; i < count; i++) {
        ret.push(this.get(this.index + i));
      }
      return ret;
    }
    random() {
      const index = int(random(this.series.length));
      return this.series[index];
    }
    reset(ix = 0) {
      this.index = ix % this.series.length;
      return this;
    }
    shuffle() {
      this.series = shuffle(this.series);
      return this;
    }
  };
  var ColorStack = class _ColorStack extends RingStack {
    duplicate() {
      return new _ColorStack(this.series);
    }
    background() {
      if (!this.options.background) {
        this.options.background = this.burnRandom();
      }
      return this.options.background;
    }
    stroke() {
      if (!this.options.stroke) {
        this.options.stroke = this.burnRandom();
      }
      return this.options.stroke;
    }
    nextWithOpacity(opacity) {
      const val = this.next();
      const r = val.slice(1, 3);
      const g = val.slice(3, 5);
      const b = val.slice(5, 7);
      const rgba = `rgba(${unhex(r)}, ${unhex(g)}, ${unhex(b)}, ${opacity})`;
      return color(rgba);
    }
  };
  function chromatomeColors(pallette) {
    if (!pallette) {
      return new ColorStack(chromotome.getRandom().colors);
    }
    const chroma = chromotome.get(pallette);
    return new ColorStack(chroma.colors, chroma);
  }

  // contents/sketches/sawtooth.ts
  var colors;
  var bg;
  var fg;
  var fg2;
  var usableHeight = 500;
  var usableWidth = 500;
  function setup() {
    const canvasElement = document.getElementById("sawtooth");
    if (canvasElement) {
      usableHeight = parseInt(canvasElement.height, 10);
      usableWidth = parseInt(canvasElement.width, 10);
    }
    console.table({ usableHeight, usableWidth });
    console.log("canvasElement");
    console.log(canvasElement);
    createCanvas(usableWidth, usableHeight, canvasElement);
    colors = chromatomeColors();
    background(colors.background());
  }
  function SawToothWithDoubleCircle(x, y, span, teeth, bg2, fg3, triangleWidth = 4) {
    push();
    translate(x, y);
    SawTooth(0, 0, span, teeth, bg2, fg3, triangleWidth);
    noFill();
    stroke(bg2);
    strokeWeight(span / 18);
    circle(0, 0, span * 0.7);
    noStroke();
    fill(bg2);
    circle(0, 0, span * 0.55);
    pop();
  }
  function SawToothWithInnerCircle(x, y, span, teeth, bg2, fg3, fg22, triangleWidth = 8) {
    push();
    translate(x, y);
    SawTooth(0, 0, span, teeth, bg2, fg22, triangleWidth);
    noStroke();
    fill(bg2);
    circle(0, 0, span * 0.25);
    pop();
  }
  function SawTooth(x, y, span, teeth, bg2, fg3, triangleWidth) {
    const increment = 2 * PI / teeth;
    noStroke();
    fill(fg3);
    for (let i = 0; i < teeth; i++) {
      i > 0 && rotate(increment);
      triangle(0, -span / triangleWidth, 0, span / triangleWidth, span / 2, 0);
    }
  }
  function keyPressed() {
    if (key === "r") {
      console.log("redrawing");
      colors = chromatomeColors();
      background(colors.background());
      draw();
    }
  }
  function draw() {
    noLoop();
    blendMode(BLEND);
    const span = Math.floor(usableHeight / 6);
    bg = colors.background();
    fg = colors.next();
    fg2 = colors.next();
    for (let y = 0; y < usableHeight / span + 1; y++) {
      for (let x = 0; x < usableWidth / span + 1; x++) {
        SawToothWithDoubleCircle(x * span, y * span, span, 30, bg, fg, 4);
        SawToothWithInnerCircle(
          x * span + span / 2,
          y * span + span / 2,
          span / 3,
          8,
          bg,
          fg,
          fg2,
          8
        );
      }
    }
  }